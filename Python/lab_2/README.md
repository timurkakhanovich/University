# Задание 1. Вектор
Реализовать класс “n-мерный вектор”. У этого класса должны быть определены все
естественные для математического вектора операции – сложение, вычитание, умножение
на константу, скалярное произведение, сравнение на равенство и другие. Кроме этого
должны быть операции вычисления длины, получение элемента по индексу, а также стро-
ковое представление и т.д. По возможности и необходимости использовать такие возмож-
ности, как декораторы, дескрипторы и т.д. (считаем, что изначально вектор представляет
собой вектор-столбец).

# Задание 2. Public/Private/Protected
Придумать и реализовать механизм задания Public/Private/Protected аттрибутов клас-
са/объкта. При этом к Public аттрибутам пользователь фактически имеет доступ из лю-
бой точки кода с использованием объекта/класса; к Private аттрибутам получить доступ
можно только внутри класса; к Protected – только внутри класса и его предках. Механизм
должен быть максимально общим, что позволяет тспользовать его для любого пользова-
тельского класса и его аттрибутов. Реализовать две и более различных реализации этого
механизма (различными являются только те реализации, которые использует разные ме-
ханизмы/протоколы языка Python). Для защиты задания можно сдать только один способ
реализации (но не рекомендуется).

# Задание 3. Логгирование
Класс логгер с возможностью наследования. Класс должен логировать то, какие ме-
тоды и с какими аргументами у него вызывались и какой был результат этого вызова.
Функция str() от этого класса должна отдавать лог вызовов. Должна быть возможность
унаследоваться от такого класса, чтобы добавить логгирование вызовов у любого класса.
При форматировании строк использовать метод format. Механизм должен быть макси-
мально общим, что позволяет тспользовать его для любого пользовательского класса. (под 
возможностью насследования имеется в виду то, что основное его использование произ-
водится не через наследование а через другие механизмы/протоколы языка однако такая
возможность должна присутствовать).

# Задание 4. Рекурсивный defaultdict
Реализовать свой класс-аналог defaultdict, который позволяет рекурсивно читать и
записывать значения в виде d[“a”][“b”][“c”] = 1, а при вызове str(d) выводит данные как
словарь в текстовом представлении.

# Задание 5. @cached
Декторатор @cached, который сохраняет значение функции при каждом вызове. Если
функция вызвана повторно с теми же аргументами, то возвращается сохраненное значе-
ние, а функция не вычисляется.

# Задание 6. range
Реализовать полностью свой класс range с аналогичным встроенному интерфейсом.
(наследование использовать запрещенно, вызовы и использование встроенного range за-
прещенно; класс должен быть реализован снуля)

# Задание 7. Последовательность с фильтрацией
Реализовать класс, соответствующий некоторой последовательности объектов и имею-
щий следующие методы:
1. Создать объект на основе произвольного iterable объекта.
2. Итерирование (__iter__) по элементам (неистощаемое – можно несколько раз ис-
пользовать объект в качестве iterable для for).
3. Отфильтровать последовательность с помощью некоторой функции и вернуть новую
сокращенную последовательность, в которой присутствуют только элементы, для
которых эта функция вернула True.

# Задание 8. Синглтон
Реализовать шаблон проектирования Singleton, который можно применять на произ-
вольный класс. Разработать самостоятельно, как этот инструмент будет применяться к
целевому классу (например, модифицировать исходный класс или изменять способ вызо-
ва конструктора).

# Задание 9. Дескриптор с комиссией
Часто при зачислении каких-то средств на счет с нас берут комиссию. Давайте реали-
зуем похожий механизм с помощью дескрипторов. Напишите дескриптор Value, который
будет использоваться в классе Account. У аккаунта будет атрибут comission. Именно эту
коммиссию (выраженную в процентах) и нужно вычитать при присваивании значений в
amount.

# Задание 10. FieldInitializer с проверкой типов
Иногда бывает утомительно писать код при инициализации инстанса класса. Если по-
лей много - это унылый процесс. Нужно написать метакласс FieldInitializer, который бы
избавлял от этой рутины. Метакласс должен брать все keyword аргументы инициализато-
ра и создавать в инстансе класса атрибуты с соответствующими именами и значениями.
Более формально, то если вы передаете в аргумент конструктора класса именованные ар-
гументы, которых нет в его сигнатуре, то нужно сначала создать объект класса, передав в
его конструктор все аргументы, соответствующие сигнатуре __init__ (как позиционные,
так и именованные), и после этого проставить те атрибуты, соотвествующие всем пере-
данным пользователем именованным аргументам, которые еще не установлены у объекта.
По мимо этого тип первого присвоенного значения любому аттрибуту является его основ-
ным и значения никакого другого типа хранится не могут, то есть при инициализации
экземпляра класса был создан аттрибут с чилом 1 (объект класса int), и в случае если
пользователь попытается присвоить этому аттрибуту занчение отличное от int (например,
число с плавающей точкой 2,5), то должно быть вызванно исключение с соответствующим
сообщением.

# Задание 11. Exception info
Стандартный питоновский трейсбек показывает номера строк по пути вызова функций,
которые привели к выбросу исключения. На самом деле питон позволяет получить гораздо
больше информации о контексте исключения. В этой задаче вам нужно написать декора-
тор exception_info, который если декорируемая функция завершилась успешно, то нужно
вернуть результат выполнения. Если же декорируемая функция вернула исключения, то
нужно перехватить его и вернуть тапл, первым элементом которого является строка ко-
да в функции, которая шла непосредственно перед строкой, в которой было выброшено
исключение, а вторым элементом должен быть словарь аргументов функции, в которой
было выброшено исключение, т.е. ключом должно быть имя переменной-аргумента, а зна-
чением значение этой переменной. Разрешается использовать модули traceback и inspect.
